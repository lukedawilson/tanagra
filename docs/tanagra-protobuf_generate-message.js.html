<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: tanagra-protobuf/generate-message.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: tanagra-protobuf/generate-message.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const protobuf = require('protobufjs')
const memcache = require('memory-cache')

const primitiveTypes = require('./primitive-types')
const KeyValuePair = require('./key-value-pair')
const getTypeId = require('./get-type-id')

function generateMessage(instance) {
  const message = new protobuf.Type(getTypeId(instance))
  message.add(new protobuf.Field('_serializationKey', 999, 'string'))

  let i = 0
  const fields = Object.entries(instance)
  for (const field of fields) {
    const name = field[0], value = field[1]
    if (name === '_serializationKey') continue
    if (value === null || value === undefined) continue

    const type = getTypeId(value)
    i = addProtoField(message, name, value, i, type)
  }

  return message
}

function addProtoField(message, name, value, i, type, rule = undefined) {
  if (primitiveTypes[type]) {
    message.add(new protobuf.Field(name, i++, primitiveTypes[type], rule))
  } else if ((type === 'Array' || type === 'Map') &amp;&amp; rule) {
    // Do nothing - we don't support applying rules to arrays or maps (e.g. arrays of arrays, arrays of maps, etc.)
  } else if (type === 'Array') {
    if (!value.some(x => x === null || x === undefined)) {
      const childValue = value[0], childType = getTypeId(childValue)
      i = addProtoField(message, name, childValue, i, childType, 'repeated')
    }
  } else if (type === 'Map') {
    let hasNulls = false, childKey = null, childValue
    for (let [k, v] of value) {
      if (k === null || k === undefined || v === null || v === undefined) {
        hasNulls = true
        break
      }

      if (childKey === null) {
        childKey = k
        childValue = v
      }
    }

    if (!hasNulls) {
      const kvp = new KeyValuePair(childKey, childValue)
      const childMessage = getOrGenerateMessage(kvp)
      if (!message.get(childMessage.name)) message.add(childMessage)
      message.add(new protobuf.Field(`${name}_map`, i++, childMessage.name, 'repeated'))
    }
  } else {
    const subMessage = getOrGenerateMessage(value)
    if (!message.get(subMessage.name)) message.add(subMessage)
    message.add(new protobuf.Field(name, i++, subMessage.name, rule))
  }

  return i
}

function addNormalisedMapsToInstance(instance) {
  if (instance === null || instance === undefined) return

  const fields = Object.entries(instance)
  for (const field of fields) {
    const name = field[0], value = field[1]
    if (value === null || value === undefined) continue

    const type = getTypeId(value)
    if (type === 'Array') {
      value.forEach(addNormalisedMapsToInstance)
    } else if (type === 'Map') {
      const mapArray = []
      let hasNulls = false
      for (let [k, v] of value) {
        if (k === null || k === undefined || v === null || v === undefined) {
          hasNulls = true
          break
        }

        mapArray.push(new KeyValuePair(k, v))
      }

      if (!hasNulls) {
        instance[`${name}_map`] = mapArray
        Array.from(value.values()).forEach(addNormalisedMapsToInstance)
      }
    } else if (!primitiveTypes[type]) {
      addNormalisedMapsToInstance(value)
    }
  }
}

function getOrGenerateMessage(instance) {
  const typeId = getTypeId(instance)
  const existing = typeId &amp;&amp; memcache.get(typeId)
  if (existing) {
    return existing
  }

  const newMessage = generateMessage(instance)
  memcache.put(typeId, newMessage)
  return newMessage
}

/**
 * Generates a protobuf schema for a given decorated class instance.
 *
 * @package
 * @memberOf module:tanagra-protobuf
 * @function generateMessage
 * @param instance Instance of a class decorated with serialization metadata.
 * @returns {protobuf.Type}
 */
module.exports = instance => {
  const message = getOrGenerateMessage(instance)
  addNormalisedMapsToInstance(instance)
  return message
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-tanagra-auto-mapper.html">tanagra-auto-mapper</a></li><li><a href="module-tanagra-core.html">tanagra-core</a></li><li><a href="module-tanagra-json.html">tanagra-json</a></li><li><a href="module-tanagra-protobuf.html">tanagra-protobuf</a></li><li><a href="module-tanagra-protobuf-redis-cache.html">tanagra-protobuf-redis-cache</a></li></ul><h3>Classes</h3><ul><li><a href="module-tanagra-protobuf.CustomReader.html">CustomReader</a></li><li><a href="module-tanagra-protobuf.KeyValuePair.html">KeyValuePair</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Mon Feb 24 2020 13:22:49 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
